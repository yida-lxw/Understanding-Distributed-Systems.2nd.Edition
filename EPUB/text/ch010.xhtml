<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch010.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="tls" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Secure links</h1>
<p>We now know how to reliably send bytes from one process to another over the network. The problem is that these bytes are sent in the clear, and a middleman could intercept the communication. To protect against that, we can use the <em>Transport Layer Security</em><a href="#fn1" class="footnote-ref" id="fnref1" epub:type="noteref">1</a> (TLS) protocol. TLS runs on top of TCP and encrypts the communication channel so that application layer protocols, like HTTP, can leverage it to communicate securely. In a nutshell, TLS provides <em>encryption</em>, <em>authentication</em>, and <em>integrity</em>.</p>
<section id="encryption" class="level2" data-number="3.1">
<h2 data-number="3.1"><span class="header-section-number">3.1</span> Encryption</h2>
<p>Encryption guarantees that the data transmitted between a client and a server is obfuscated and can only be read by the communicating processes.</p>
<p>When the TLS connection is first opened, the client and the server negotiate a shared encryption secret using <em>asymmetric encryption</em>. First, each party generates a key pair consisting of a private and public key. The processes can then create a shared secret by exchanging their public keys. This is possible thanks to some mathematical properties<a href="#fn2" class="footnote-ref" id="fnref2" epub:type="noteref">2</a> of the key pairs. The beauty of this approach is that the shared secret is never communicated over the wire.</p>
<p>Although asymmetric encryption is slow and expensive, it’s only used to create the shared encryption key. After that, <em>symmetric encryption</em> is used, which is fast and cheap. The shared key is periodically renegotiated to minimize the amount of data that can be deciphered if the shared key is broken.</p>
<p>Encrypting in-flight data has a CPU penalty, but it’s negligible since modern processors have dedicated cryptographic instructions. Therefore, TLS should be used for all communications, even those not going through the public internet.</p>
</section>
<section id="authentication" class="level2" data-number="3.2">
<h2 data-number="3.2"><span class="header-section-number">3.2</span> Authentication</h2>
<p>Although we have a way to obfuscate data transmitted across the wire, the client still needs to authenticate the server to verify it’s who it claims to be. Similarly, the server might want to authenticate the identity of the client.</p>
<p>TLS implements authentication using digital signatures based on asymmetric cryptography. The server generates a key pair with a private and a public key and shares its public key with the client. When the server sends a message to the client, it signs it with its private key. The client uses the server’s public key to verify that the digital signature was actually signed with the private key. This is possible thanks to mathematical properties<a href="#fn3" class="footnote-ref" id="fnref3" epub:type="noteref">3</a> of the key pair.</p>
<p>The problem with this approach is that the client has no idea whether the public key shared by the server is authentic. Hence, the protocol uses certificates to prove the ownership of a public key. A certificate includes information about the owning entity, expiration date, public key, and a digital signature of the third-party entity that issued the certificate. The certificate’s issuing entity is called a <em>certificate authority</em> (CA), which is also represented with a certificate. This creates a chain of certificates that ends with a certificate issued by a root CA, as shown in Figure <a href="#fig:ca-chain">3.1</a>, which self-signs its certificate.</p>
<p>For a TLS certificate to be trusted by a device, the certificate, or one of its ancestors, must be present in the trusted store of the client. Trusted root CAs, such as Let’s Encrypt<a href="#fn4" class="footnote-ref" id="fnref4" epub:type="noteref">4</a>, are typically included in the client’s trusted store by default by the operating system vendor.</p>
<div class="figure" style="text-align: center">
<img alt="A certificate chain ends with a self-signed certificate issued by a root CA." width="40%" src="../media/file7.png" />
<p class="caption">
Figure 3.1: A certificate chain ends with a self-signed certificate issued by a root CA.
</p>
</div>
<p>When a TLS connection is opened, the server sends the full certificate chain to the client, starting with the server’s certificate and ending with the root CA. The client verifies the server’s certificate by scanning the certificate chain until it finds a certificate that it trusts. Then, the certificates are verified in reverse order from that point in the chain. The verification checks several things, like the certificate’s expiration date and whether the digital signature was actually signed by the issuing CA. If the verification reaches the last certificate in the path (the server’s own certificate) without errors, the path is verified, and the server is authenticated.</p>
<p>One of the most common mistakes when using TLS is letting a certificate expire. When that happens, the client won’t be able to verify the server’s identity, and opening a connection to the remote process will fail. This can bring an entire application down as clients can no longer connect with it. For this reason, automation to monitor and auto-renew certificates close to expiration is well worth the investment.</p>
</section>
<section id="integrity" class="level2" data-number="3.3">
<h2 data-number="3.3"><span class="header-section-number">3.3</span> Integrity</h2>
<p>Even if the data is obfuscated, a middleman could still tamper with it; for example, random bits within the messages could be swapped. To protect against tampering, TLS verifies the integrity of the data by calculating a message digest. A secure hash function is used to create a message authentication code<a href="#fn5" class="footnote-ref" id="fnref5" epub:type="noteref">5</a> (HMAC). When a process receives a message, it recomputes the digest of the message and checks whether it matches the digest included in the message. If not, then the message has either been corrupted during transmission or has been tampered with. In this case, the message is dropped.</p>
<p>The TLS HMAC protects against data corruption as well, not just tampering. You might be wondering how data can be corrupted if TCP is supposed to guarantee its integrity. While TCP does use a checksum to protect against data corruption, it’s not 100% reliable<a href="#fn6" class="footnote-ref" id="fnref6" epub:type="noteref">6</a>: it fails to detect errors for roughly 1 in 16 million to 10 billion packets. With packets of 1 KB, this is expected to happen once per 16 GB to 10 TB transmitted.</p>
</section>
<section id="handshake" class="level2" data-number="3.4">
<h2 data-number="3.4"><span class="header-section-number">3.4</span> Handshake</h2>
<p>When a new TLS connection is established, a handshake between the client and server occurs during which:</p>
<ol type="1">
<li>The parties agree on the cipher suite to use. A cipher suite specifies the different algorithms that the client and the server intend to use to create a secure channel, like the:
<ul>
<li>key exchange algorithm used to generate shared secrets;</li>
<li>signature algorithm used to sign certificates;</li>
<li>symmetric encryption algorithm used to encrypt the application data;</li>
<li>HMAC algorithm used to guarantee the integrity and authenticity of the application data.</li>
</ul></li>
<li>The parties use the key exchange algorithm to create a shared secret. The symmetric encryption algorithm uses the shared secret to encrypt communication on the secure channel going forward.</li>
<li>The client verifies the certificate provided by the server. The verification process confirms that the server is who it says it is. If the verification is successful, the client can start sending encrypted application data to the server. The server can optionally also verify the client certificate if one is available.</li>
</ol>
<p>These operations don’t necessarily happen in this order, as modern implementations use several optimizations to reduce round trips. For example, the handshake typically requires 2 round trips with TLS 1.2 and just one with TLS 1.3. The bottom line is that creating a new connection is not free: yet another reason to put your servers geographically closer to the clients and reuse connections when possible.</p>
</section>
</section>
<section class="footnotes" epub:type="footnotes">
<hr />
<ol>
<li id="fn1" epub:type="footnote"><p>“RFC 8446: The Transport Layer Security (TLS) Protocol Version 1.3,” <a href="https://datatracker.ietf.org/doc/html/rfc8446" class="uri">https://datatracker.ietf.org/doc/html/rfc8446</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" epub:type="footnote"><p>“A (Relatively Easy To Understand) Primer on Elliptic Curve Cryptography,” <a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/" class="uri">https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" epub:type="footnote"><p>“Digital signature,” <a href="https://en.wikipedia.org/wiki/Digital_signature" class="uri">https://en.wikipedia.org/wiki/Digital_signature</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" epub:type="footnote"><p>“Let’s Encrypt: A nonprofit Certificate Authority,” <a href="https://letsencrypt.org/" class="uri">https://letsencrypt.org/</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" epub:type="footnote"><p>“RFC 2104: HMAC: Keyed-Hashing for Message Authentication,” <a href="https://datatracker.ietf.org/doc/html/rfc2104" class="uri">https://datatracker.ietf.org/doc/html/rfc2104</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" epub:type="footnote"><p>“When the CRC and TCP checksum disagree,” <a href="https://dl.acm.org/doi/10.1145/347057.347561" class="uri">https://dl.acm.org/doi/10.1145/347057.347561</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
