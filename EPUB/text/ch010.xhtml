<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch010.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="tls" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> 安全链接</h1>
<p>现在我们知道如何通过网络可靠地将字节数据从一个进程发送到另一个进程。但问题是这些字节数据都是以明文形式发送，中间人可能会拦截我们的通信。为了避免这种情况, 我们可以使用 <em>传输层安全协议(TLS)</em><a href="#fn1" class="footnote-ref" id="fnref1" epub:type="noteref">1</a> 。TLS是运行在TCP之上，并且对通信信道进行了加密。因此，应用层协议，比如HTTP，可以利用TLS来进行安全通信。简而言之，TLS协议提供了数据的 <em>加密</em>, <em>认证</em>,  以及保证了通信数据的<em>完整性</em>。</p>
<section id="encryption" class="level2" data-number="3.1">
<h2 data-number="3.1"><span class="header-section-number">3.1</span> 加密</h2>
<p>加密保证了客户端和服务端之间传输的数据是经过混淆的，且只能被通信进程读取。</p>
<p>当TLS连接首次建立时，客户端和服务端会使用<em>非对称加密</em>来协商一个共享的密钥。首先，双方都会生成一个由私钥和公钥组成的密钥对。然后进程可以通过交换它们的公钥来创建一个共享的密钥。这要得益于密钥对的一些数学特性<a href="#fn2" class="footnote-ref" id="fnref2" epub:type="noteref">2</a>。这种方式的优美之处在于共享密钥从未通过网络进行传输。</p>
<p>尽管非对称加密执行效率很慢且开销大，但是它仅仅只用于创建共享密钥。然后便会切换至高效且经济的<em>对称加密</em>方式。系统会定期重新协商共享密钥，即使密钥遭破解，也能将可解密的数据量控制在最小范围。</p>
<p>对正在传输中的数据进行加密虽然会带来CPU开销，但是由于现代处理器都自带了专门的加密指令集，这种开销几乎可以忽略不计。因此，所有通信传输，包括非公网环境,都应采用TLS加密。</p>
</section>
<section id="authentication" class="level2" data-number="3.2">
<h2 data-number="3.2"><span class="header-section-number">3.2</span> 认证</h2>
<p>尽管我们已有对通过网络传输的数据进行加密混淆的应对之策，但是客户端仍需要认证服务器，以确认其真实身份。同样的，服务端也可能需要认证客户端的身份。</p>
<p>TLS通过基于非对称加密的数字签名实现身份认证。服务器生成包含公钥和私钥的密钥对，并将其公钥共享给客户端。当服务器向客户端发送消息时，会使用私钥进行签名。客户端则利用服务器的公钥验证该数字签名确实由对应私钥生成——这一切都得益于密钥对特有的数学特性<a href="#fn3" class="footnote-ref" id="fnref3" epub:type="noteref">3</a>。</p>
<p>这种机制存在一个关键问题：客户端无法确认服务器提供的公钥是否真实可信。因此，协议采用数字证书来验证公钥所有权。证书包含主体信息、有效期、公钥以及签发该证书的第三方机构数字签名。证书签发机构称为<em>证书颁发机构</em>(CA)，其本身也由证书表示身份，这将创建一个证书链，该证书链以根CA颁发的证书作为结束，如图<a href="#fig:ca-chain">3.1</a>所示，根CA自签名其证书。</p>
<p>要使设备信任某个TLS证书，该证书或其任一上级证书必须存在于客户端的信任存储区中。操作系统厂商通常默认在客户端信任存储中预置受信任的根证书颁发机构(比如Let's Encrypt<a href="#fn4" class="footnote-ref" id="fnref4" epub:type="noteref">4</a>)的证书。</p>
<div class="figure" style="text-align: center">
<img alt="A certificate chain ends with a self-signed certificate issued by a root CA." width="40%" src="../media/file7.png" />
<p class="caption">
图3.1：一个证书链以根CA颁发的自签名证书作为结束。
</p>
</div>
<p>当建立TLS连接时，服务器会向客户端发送完整的证书链——从服务器证书开始，到根CA证书结束。客户端通过扫描证书链来验证服务器证书，直至找到其信任的证书为止。随后，系统将从该信任点开始沿证书链反向验证：检查证书有效期、数字签名是否确实由签发CA签署等多项要素。若验证过程能无差错地抵达证书路径末端(服务器自身证书)，则路径验证通过，服务器身份即认证通过。</p>
<p>使用TLS时最常犯的错误就是未能及时更新过期证书。一旦证书失效，客户端将无法验证服务器身份，导致远程连接建立失败。这种情况可能致使整个系统瘫痪——因为客户端将完全无法接入服务。因此，部署临近过期的证书自动监控与续订机制至关重要。</p>
</section>
<section id="integrity" class="level2" data-number="3.3">
<h2 data-number="3.3"><span class="header-section-number">3.3</span> 完整性</h2>
<p>即便数据经过混淆处理，中间人仍可能实施篡改——例如替换消息中的随机比特位。为此，TLS会通过计算消息摘要来验证数据完整性：系统采用安全散列函数生成消息认证码<a href="#fn5" class="footnote-ref" id="fnref5" epub:type="noteref">5</a>(HMAC)。接收进程在处理消息时，将重新计算消息摘要并与原始摘要做比对。若两者不一致，则表明消息在传输过程中已遭损坏或篡改，此时系统会直接丢弃该消息。</p>
<p>TLS的HMAC机制不仅能防范篡改，还可以防止数据损坏。您可能会疑惑：既然TCP协议理应保证数据完整性，为何还会出现数据损坏？虽然TCP确实通过校验和(checksum)来防止数据损坏，但该机制并非100%可靠<a href="#fn6" class="footnote-ref" id="fnref6" epub:type="noteref">6</a>:其错误检测的失败率大约为每1600万至100亿个数据包中出现1次。以1KB的数据包计算，相当于每传输16GB至10TB数据就可能发生一次漏检。</p>
</section>
<section id="handshake" class="level2" data-number="3.4">
<h2 data-number="3.4"><span class="header-section-number">3.4</span> 握手</h2>
<p>建立新的TLS连接时，客户端与服务器将通过握手协议完成以下交互流程：</p>
<ol type="1">
<li>双方需协商确定使用的密码套件。该套件将明确规定客户端与服务器用于建立安全通道的各项算法，比如：
<ul>
<li>密钥交换算法：用于生成共享密钥</li>
<li>签名算法：用于证书签名验证</li>
<li>对称加密算法：用于加密应用数据</li>
<li>HMAC算法：用于保证应用数据的完整性与真实性</li>
</ul></li>
<li>双方通过密钥交换算法生成共享密钥，随后由对称加密算法利用该密钥对安全通道中的所有通信内容进行加密。</li>
<li>客户端将验证服务器提供的证书，该过程用于确认服务器身份的真实性。若验证通过，客户端即可开始向服务器发送加密的应用数据。服务器也可按需在客户端提供证书时对其进行验证。</li>
</ol>
<p>这些操作并不严格遵循既定先后顺序，现代协议实现会通过多项优化来减少交互次数。例如：TLS 1.2通常需要2次握手交互，而TLS 1.3仅需1次。关键在于，建立新连接必然存在开销——这再次印证了应当尽可能将服务器部署在靠近客户端的地理位置，并复用现有连接的重要性。</p>
</section>
</section>
<section class="footnotes" epub:type="footnotes">
<hr />
<ol>
<li id="fn1" epub:type="footnote"><p>“RFC 8446: 传输层安全协议(TLS) 版本1.3,” <a href="https://datatracker.ietf.org/doc/html/rfc8446" class="uri">https://datatracker.ietf.org/doc/html/rfc8446</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" epub:type="footnote"><p>“椭圆曲线密码学入门指南(相对容易理解),” <a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/" class="uri">https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" epub:type="footnote"><p>“数字签名,” <a href="https://en.wikipedia.org/wiki/Digital_signature" class="uri">https://en.wikipedia.org/wiki/Digital_signature</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" epub:type="footnote"><p>“Let’s Encrypt: 一家非盈利性的证书颁发机构,” <a href="https://letsencrypt.org/" class="uri">https://letsencrypt.org/</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" epub:type="footnote"><p>“RFC 2104: HMAC: 用于消息认证的密钥哈希,” <a href="https://datatracker.ietf.org/doc/html/rfc2104" class="uri">https://datatracker.ietf.org/doc/html/rfc2104</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" epub:type="footnote"><p>“当循环冗余校验(CRC)和传输控制协议(TCP)校验和不一致时,” <a href="https://dl.acm.org/doi/10.1145/347057.347561" class="uri">https://dl.acm.org/doi/10.1145/347057.347561</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
