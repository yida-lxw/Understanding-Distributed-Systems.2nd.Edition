<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch027.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="httpcaching" class="level1" data-number="14">
<h1 data-number="14"><span class="header-section-number">14</span> HTTP caching</h1>
<p><em>Cruder</em>’s application server handles both static and dynamic resources at this point. A static resource contains data that usually doesn’t change from one request to another, like a JavaScript or CSS file. Instead, a dynamic resource is generated by the server on the fly, like a JSON document containing the user’s profile.</p>
<p>Since a static resource doesn’t change often, it can be cached. The idea is to have a client (i.e., a browser) cache the resource for some time so that the next access doesn’t require a network call, reducing the load on the server and the response time.<a href="#fn1" class="footnote-ref" id="fnref1" epub:type="noteref">1</a></p>
<p>Let’s see how client-side HTTP caching works in practice with a concrete example. HTTP caching is limited to safe request methods that don’t alter the server’s state, like GET or HEAD. Suppose a client issues a GET request for a resource it hasn’t accessed before. The local cache intercepts the request, and if it can’t find the resource locally, it will go and fetch it from the origin server on behalf of the client.</p>
<p>The server uses specific HTTP response headers<a href="#fn2" class="footnote-ref" id="fnref2" epub:type="noteref">2</a> to let clients know that a resource is cachable. So when the server responds with the resource, it adds a <em>Cache-Control</em> header that defines for how long to cache the resource (TTL) and an <em>ETag</em> header with a version identifier. Finally, when the cache receives the response, it stores the resource locally and returns it to the client (see Figure <a href="#fig:cache1">14.1</a>).</p>
<div class="figure" style="text-align: center">
<img alt="A client accessing a resource for the first time (the Age header contains the time in seconds the object was in the cache)" width="100%" src="../media/file35.png" />
<p class="caption">
Figure 14.1: A client accessing a resource for the first time (the Age header contains the time in seconds the object was in the cache)
</p>
</div>
<p>Now, suppose some time passes and the client tries to access the resource again. The cache first checks whether the resource hasn’t expired yet, i.e., whether it’s <em>fresh</em>. If so, the cache immediately returns it. However, even if the resource hasn’t expired from the client’s point of view, the server may have updated it in the meantime. That means reads are not strongly consistent, but we will safely assume that this is an acceptable tradeoff for our application.</p>
<p>If the resource has expired, it’s considered <em>stale</em>. In this case, the cache sends a GET request to the server with a conditional header (like <em>If-None-Match</em>) containing the version identifier of the stale resource to check whether a newer version is available. If there is, the server returns the updated resource; if not, the server replies with a <em>304 Not Modified</em> status code (see Figure <a href="#fig:cache3">14.2</a>).</p>
<div class="figure" style="text-align: center">
<img alt="A client accessing a stale resource" width="100%" src="../media/file36.png" />
<p class="caption">
Figure 14.2: A client accessing a stale resource
</p>
</div>
<p>Ideally, a static resource should be immutable so that clients can cache it “forever,” which corresponds to a maximum length of a year according to the HTTP specification. We can still modify a static resource if needed by creating a new one with a different URL so that clients will be forced to fetch it from the server.</p>
<p>Another advantage of treating static resources as immutable is that we can update multiple related resources atomically. For example, if we publish a new version of the application’s website, the updated HTML index file is going to reference the new URLs for the JavaScript and CSS bundles. Thus, a client will see either the old version of the website or the new one depending on which index file it has read, but never a mix of the two that uses, e.g., the old JavaScript bundle with the new CSS one.</p>
<p>Another way of thinking about HTTP caching is that we treat the read path (<em>GET</em>) differently from the write path (<em>POST, PUT, DELETE</em>) because we expect the number of reads to be several orders of magnitude higher than the number of writes. This is a common pattern referred to as the <em>Command Query Responsibility Segregation</em><a href="#fn3" class="footnote-ref" id="fnref3" epub:type="noteref">3</a> (CQRS) pattern.<a href="#fn4" class="footnote-ref" id="fnref4" epub:type="noteref">4</a></p>
<p>To summarize, allowing clients to cache static resources has reduced the load on our server, and all we had to do was to play with some HTTP headers! We can take caching one step further by introducing a server-side HTTP cache with a reverse proxy.</p>
<section id="reverse-proxies" class="level2" data-number="14.1">
<h2 data-number="14.1"><span class="header-section-number">14.1</span> Reverse proxies</h2>
<p>A <em>reverse proxy</em> is a server-side proxy that intercepts all communications with clients. Since the proxy is indistinguishable from the actual server, clients are unaware that they are communicating through an intermediary (see Figure <a href="#fig:reverseproxy">14.3</a>).</p>
<div class="figure" style="text-align: center">
<img alt="A reverse proxy acts as an intermediary between the clients and the servers." width="90%" src="../media/file37.png" />
<p class="caption">
Figure 14.3: A reverse proxy acts as an intermediary between the clients and the servers.
</p>
</div>
<p>A common use case for a reverse proxy is to cache static resources returned by the server. Since the cache is shared among the clients, it will decrease the load of the server a lot more than any client-side cache ever could.</p>
<p>Because a reverse proxy is a middleman, it can be used for much more than just caching. For example, it can:</p>
<ul>
<li>authenticate requests on behalf of the server;</li>
<li>compress a response before returning it to the client to speed up the transmission;</li>
<li>rate-limit requests coming from specific IPs or users to protect the server from being overwhelmed;</li>
<li>load-balance requests across multiple servers to handle more load.</li>
</ul>
<p>We will explore some of these use cases in the next chapters. NGINX<a href="#fn5" class="footnote-ref" id="fnref5" epub:type="noteref">5</a> and HAProxy<a href="#fn6" class="footnote-ref" id="fnref6" epub:type="noteref">6</a> are widely-used reverse proxies that we could leverage to build a server-side cache. However, many use cases for reverse proxies have been commoditized by managed services. So, rather than building out a server-side cache, we could just leverage a <em>Content Delivery Network</em> (CDN).</p>
</section>
</section>
<section class="footnotes" epub:type="footnotes">
<hr />
<ol>
<li id="fn1" epub:type="footnote"><p>This is an example of the replication pattern in action.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" epub:type="footnote"><p>“HTTP caching,” <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" class="uri">https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" epub:type="footnote"><p>“CQRS,” <a href="https://martinfowler.com/bliki/CQRS.html" class="uri">https://martinfowler.com/bliki/CQRS.html</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" epub:type="footnote"><p>This is another instance of functional decomposition.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" epub:type="footnote"><p>“NGINX,” <a href="https://www.nginx.com/" class="uri">https://www.nginx.com/</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" epub:type="footnote"><p>“HAProxy,” <a href="https://www.haproxy.com/" class="uri">https://www.haproxy.com/</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
