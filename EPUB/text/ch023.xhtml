<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch023.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="asynctransactions" class="level1" data-number="13">
<h1 data-number="13"><span class="header-section-number">13</span> Asynchronous transactions</h1>
<p>2PC is a synchronous blocking protocol — if the coordinator or any of the participants is slow or not not available, the transaction can’t make progress. Because of its blocking nature, 2PC is generally combined with a blocking concurrency control protocol, like 2PL, to provide isolation. That means the participants are holding locks while waiting for the coordinator, blocking other transactions accessing the same objects from making progress.</p>
<p>The underlying assumptions of 2PC are that the coordinator and the participants are available and that the duration of the transaction is short-lived. While we can do something about the participants’ availability by using state machine replication, we can’t do much about transactions that, due to their nature, take a long time to execute, like hours or days. In this case, blocking just isn’t an option. Additionally, if the participants belong to different organizations, the organizations might be unwilling to grant each other the power to block their systems to run transactions they don’t control.</p>
<p>To solve this problem, we can look for solutions in the real world. For example, consider a fund transfer between two banks via a cashier’s check. First, the bank issuing the check deducts the funds from the source account. Then, the check is physically transported to the other bank and there it’s finally deposited to the destination account. For the fund transfer to work, the check cannot be lost or deposited more than once. Since neither the source nor destination bank had to wait on each other while the transaction was in progress, the fund transfer via check is an asynchronous (non-blocking) atomic transaction. However, the price to pay for this is that the source and destination account are in an inconsistent state while the check is being transferred. So although asynchronous transactions are atomic, they are not isolated from each other.</p>
<p>Now, because a check is just a message, we can generalize this idea with the concept of <em>persistent</em> messages sent over the network, i.e., messages that that are guaranteed to be processed <em>exactly once</em>. In this chapter, we will discuss a few implementations of asynchrounous transactions based on this concept.</p>
<section id="log-based-transactions" class="level2" data-number="13.1">
<h2 data-number="13.1"><span class="header-section-number">13.1</span> Outbox pattern</h2>
<p>A common pattern<a href="#fn1" class="footnote-ref" id="fnref1" epub:type="noteref">1</a> in modern applications is to replicate the same data to different data stores tailored to different use cases. For example, suppose we own a product catalog service backed by a relational database, and we decide to offer an advanced full-text search capability in its API. Although some relational databases offer a basic full-text search functionality, a dedicated service such as Elasticsearch<a href="#fn2" class="footnote-ref" id="fnref2" epub:type="noteref">2</a> is required for more advanced use cases.</p>
<p>To integrate with the search service, the catalog service needs to update both the relational database and the search service when a new product is added, or an existing product is modified or deleted. The service could update the relational database first and then the search service, but if the service crashes before updating the search service, the system would be left in an inconsistent state. So we need to wrap the two updates into a transaction somehow.</p>
<p>We could consider using 2PC, but while the relational database supports the X/Open XA<a href="#fn3" class="footnote-ref" id="fnref3" epub:type="noteref">3</a> 2PC standard, the search service doesn’t, which means we would have to implement the protocol for the search service somehow. We also don’t want the catalog service to block if the search service is temporarily unavailable. Although we want the two data stores to be in sync, we can accept some temporary inconsistencies. So eventual consistency is acceptable for our use case.</p>
<p>We can solve this problem by having the catalog service send a persistent message to the search service whenever a product is added, modified or deleted. One way of implementing that is for a local transaction to append the message to a dedicated <em>outbox</em> table<a href="#fn4" class="footnote-ref" id="fnref4" epub:type="noteref">4</a> when it makes a change to the product catalog. Because the relational database supports ACID transactions, the message is appended to the outbox table if and only if the local transaction commits and is not aborted.</p>
<p>The outbox table can then be monitored by a dedicated <em>relay process</em>. When the relay process discovers a new message, it sends the message to the destination, the search service. The relay process deletes the message from the table only when it receives an acknolowedgment that it was was delivered successfully. Unsurprisingly, it’s possible for the same message to be delivered multiple times. For example, if the relay process crashes after sending the message but before removing it from the table, it will resend the message when it restarts. To guarantee that the destination processes the message only once, an idempotency key is assigned to it so that the message can be deduplicated (we discussed this in chapter <a href="#idempotency">5.7</a>).</p>
<p>In practice, the relay process doesn’t send messages directly to the destination. Instead, it forwards messages to a message channel<a href="#fn5" class="footnote-ref" id="fnref5" epub:type="noteref">5</a>, like Kafka<a href="#fn6" class="footnote-ref" id="fnref6" epub:type="noteref">6</a> or Azure Event Hubs<a href="#fn7" class="footnote-ref" id="fnref7" epub:type="noteref">7</a>, responsible for delivering them to one or more destinations in the same order as they were appended. Later in chapter <a href="#messaging">23</a>, we will discuss message channels in more detail.</p>
<p>If you squint a little, you will see that what we have just implemented here is conceptually similar to state machine replication, where the state is represented by the products in the catalog, and the replication happens through a log of operations (the outbox table).</p>
</section>
<section id="sagas" class="level2" data-number="13.2">
<h2 data-number="13.2"><span class="header-section-number">13.2</span> Sagas</h2>
<p>Now suppose we own a travel booking service. To book a trip, the travel service has to atomically book a flight through a dedicated service and a hotel through another. However, either of these services can fail their respective request. If one booking succeeds, but the other fails, then the former needs to be canceled to guarantee atomicity. Hence, booking a trip requires multiple steps to complete, some of which are only required in case of failure. For that reason, we can’t use the simple solution presented earlier.</p>
<p>The <em>Saga</em><a href="#fn8" class="footnote-ref" id="fnref8" epub:type="noteref">8</a> pattern provides a solution to this problem. A saga is a distributed transaction composed of a set of local transactions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo>,</mo><msub><mi>T</mi><mn>2</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>T</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">T_1, T_2, ..., T_n</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mi>i</mi></msub><annotation encoding="application/x-tex">T_i</annotation></semantics></math> has a corresponding compensating local transaction <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mi>i</mi></msub><annotation encoding="application/x-tex">C_i</annotation></semantics></math> used to undo its changes. The saga guarantees that either all local transactions succeed, or, in case of failure, the compensating local transactions undo the partial execution of the transaction altogether. This guarantees the atomicity of the protocol; either all local transactions succeed, or none of them do.</p>
<p>Another way to think about sagas is that every local transaction <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mi>i</mi></msub><annotation encoding="application/x-tex">T_i</annotation></semantics></math> assumes all the other local transactions will succeed. It’s a guess, and it’s likely to be a good one, but still a guess at the end of the day. So when the guess is wrong, a mistake has been made, and an “apology<a href="#fn9" class="footnote-ref" id="fnref9" epub:type="noteref">9</a>” needs to be issued in the form of compensating transactions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mi>i</mi></msub><annotation encoding="application/x-tex">C_i</annotation></semantics></math>. This is similar to what happens in the real world when, e.g., a flight is overbooked.</p>
<p>A saga can be implemented with an orchestrator, i.e., the transaction coordinator, that manages the execution of the local transactions across the processes involved, i.e., the transaction’s participants. In our example, the travel booking service is the transaction’s coordinator, while the flight and hotel booking services are the transaction’s participants. The saga is composed of three local transactions: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>1</mn></msub><annotation encoding="application/x-tex">T_1</annotation></semantics></math> books a flight, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>2</mn></msub><annotation encoding="application/x-tex">T_2</annotation></semantics></math> books a hotel, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mn>1</mn></msub><annotation encoding="application/x-tex">C_1</annotation></semantics></math> cancels the flight booked with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>1</mn></msub><annotation encoding="application/x-tex">T_1</annotation></semantics></math>.</p>
<p>At a high level, the saga can be implemented with the <em>workflow</em><a href="#fn10" class="footnote-ref" id="fnref10" epub:type="noteref">10</a> depicted in Figure <a href="#fig:saga">13.1</a>:</p>
<ol type="1">
<li>The coordinator initiates the transaction by sending a booking request (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>1</mn></msub><annotation encoding="application/x-tex">T_1</annotation></semantics></math>) to the flight service. If the booking fails, no harm is done, and the coordinator marks the transaction as aborted.</li>
<li>If the flight booking succeeds, the coordinator sends a booking request (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>2</mn></msub><annotation encoding="application/x-tex">T_2</annotation></semantics></math>) to the hotel service. If the request succeeds, the transaction is marked as successful, and we are all done.</li>
<li>If the hotel booking fails, the transaction needs to be aborted. The coordinator sends a cancellation request (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mn>1</mn></msub><annotation encoding="application/x-tex">C_1</annotation></semantics></math>) to the flight service to cancel the previously booked flight. Without the cancellation, the transaction would be left in an inconsistent state, which would break its atomicity guarantee.</li>
</ol>
<p>The coordinator can communicate asynchronously with the participants via message channels to tolerate temporary failures. As the transaction requires multiple steps to succeed, and the coordinator can fail at any time, it needs to persist the state of the transaction as it advances. By modeling the transaction as a state machine, the coordinator can durably checkpoint its state to a data store as it transitions from one state to the next. This ensures that if the coordinator crashes and restarts, or another process is elected as the coordinator, it can resume the transaction from where it left off by reading the last checkpoint.</p>
<div class="figure" style="text-align: left">
<img alt="A workflow implementing an asynchronous transaction" width="100%" src="../media/file32.png" />
<p class="caption">
Figure 13.1: A workflow implementing an asynchronous transaction
</p>
</div>
<p>There is a caveat, though; if the coordinator crashes after sending a request but before backing up its state, it will send the same request again when it comes back online. Similarly, if sending a request times out, the coordinator will have to retry it, causing the message to appear twice at the receiving end. Hence, the participants have to de-duplicate the messages they receive to make them idempotent.</p>
<p>In practice, you don’t need to build orchestration engines from scratch to implement such workflows, since cloud compute services such as AWS Step Functions<a href="#fn11" class="footnote-ref" id="fnref11" epub:type="noteref">11</a> or Azure Durable Functions<a href="#fn12" class="footnote-ref" id="fnref12" epub:type="noteref">12</a> make it easy to create managed workflows.</p>
</section>
<section id="isolation-1" class="level2" data-number="13.3">
<h2 data-number="13.3"><span class="header-section-number">13.3</span> Isolation</h2>
<p>We started our journey into asynchronous transactions as a way to work around the blocking nature of 2PC. But to do that, we had to sacrifice the isolation guarantee that traditional ACID transactions provide. As it turns out, we can work around the lack of isolation as well. For example, one way to do that is by using <em>semantic locks</em><a href="#fn13" class="footnote-ref" id="fnref13" epub:type="noteref">13</a>. The idea is that any data the saga modifies is marked with a <em>dirty flag</em>, which is only cleared at the end of the transaction. Another transaction trying to access a dirty record can either fail and roll back its changes or wait until the dirty flag is cleared.</p>
</section>
</section>
<section class="footnotes" epub:type="footnotes">
<hr />
<ol>
<li id="fn1" epub:type="footnote"><p>“Online Event Processing: Achieving consistency where distributed transactions have failed,” <a href="https://queue.acm.org/detail.cfm?id=3321612" class="uri">https://queue.acm.org/detail.cfm?id=3321612</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" epub:type="footnote"><p>“Elasticsearch: A distributed, RESTful search and analytics engine,” <a href="https://www.elastic.co/elasticsearch/" class="uri">https://www.elastic.co/elasticsearch/</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" epub:type="footnote"><p>“Distributed Transaction Processing: The XA Specification,” <a href="https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf" class="uri">https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" epub:type="footnote"><p>“Pattern: Transactional outbox,” <a href="https://microservices.io/patterns/data/transactional-outbox.html" class="uri">https://microservices.io/patterns/data/transactional-outbox.html</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" epub:type="footnote"><p>For example, Debezium is an open source relay service that does this, see <a href="https://debezium.io/" class="uri">https://debezium.io/</a>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" epub:type="footnote"><p>“Apache Kafka: An open-source distributed event streaming platform,” <a href="https://kafka.apache.org" class="uri">https://kafka.apache.org</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" epub:type="footnote"><p>“Azure Event Hubs: A fully managed, real-time data ingestion service,” <a href="https://azure.microsoft.com/en-gb/services/event-hubs/" class="uri">https://azure.microsoft.com/en-gb/services/event-hubs/</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" epub:type="footnote"><p>“Sagas,” <a href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf" class="uri">https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" epub:type="footnote"><p>”Building on Quicksand,” <a href="https://dsf.berkeley.edu/cs286/papers/quicksand-cidr2009.pdf" class="uri">https://dsf.berkeley.edu/cs286/papers/quicksand-cidr2009.pdf</a><a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" epub:type="footnote"><p>“Clarifying the Saga pattern,” <a href="http://web.archive.org/web/20161205130022/http://kellabyte.com:80/2012/05/30/clarifying-the-saga-pattern" class="uri">http://web.archive.org/web/20161205130022/http://kellabyte.com:80/2012/05/30/clarifying-the-saga-pattern</a><a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" epub:type="footnote"><p>“AWS Step Functions,” <a href="https://aws.amazon.com/step-functions/" class="uri">https://aws.amazon.com/step-functions/</a><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" epub:type="footnote"><p>“Azure Durable Functions documentation ,” <a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/" class="uri">https://docs.microsoft.com/en-us/azure/azure-functions/durable/</a><a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" epub:type="footnote"><p>“Semantic ACID properties in multidatabases using remote procedure calls and update propagations,” <a href="https://dl.acm.org/doi/10.5555/284472.284478" class="uri">https://dl.acm.org/doi/10.5555/284472.284478</a><a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
