<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch016.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="models" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> System models</h1>
<p>To reason about distributed systems, we need to define precisely what can and can’t happen. A <em>system model</em> encodes expectations about the behavior of processes, communication links, and timing; think of it as a set of assumptions that allow us to reason about distributed systems by ignoring the complexity of the actual technologies used to implement them.</p>
<p>For example, these are some common models for communication links:</p>
<ul>
<li>The <em>fair-loss link</em> model assumes that messages may be lost and duplicated, but if the sender keeps retransmitting a message, eventually it will be delivered to the destination.</li>
<li>The <em>reliable link</em> model assumes that a message is delivered exactly once, without loss or duplication. A reliable link can be implemented on top of a fair-loss one by de-duplicating messages at the receiving side.</li>
<li>The <em>authenticated reliable link</em> model makes the same assumptions as the reliable link but additionally assumes that the receiver can authenticate the sender.</li>
</ul>
<p>Even though these models are just abstractions of real communication links, they are useful to verify the correctness of algorithms. And, as we have seen in the previous chapters, it’s possible to build a reliable and authenticated communication link on top of a fair-loss one. For example, TCP implements reliable transmission (and more), while TLS implements authentication (and more).</p>
<p>Similarly, we can model the behavior of processes based on the type of failures we expect to happen:</p>
<ul>
<li>The <em>arbitrary-fault</em> model assumes that a process can deviate from its algorithm in arbitrary ways, leading to crashes or unexpected behaviors caused by bugs or malicious activity. For historical reasons, this model is also referred to as the “Byzantine” model. More interestingly, it can be theoretically proven that a system using this model can tolerate up to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>3</mn></mfrac><annotation encoding="application/x-tex">\frac{1}{3}</annotation></semantics></math> of faulty processes<a href="#fn1" class="footnote-ref" id="fnref1" epub:type="noteref">1</a> and still operate correctly.</li>
<li>The <em>crash-recovery</em> model assumes that a process doesn’t deviate from its algorithm but can crash and restart at any time, losing its in-memory state.</li>
<li>The <em>crash-stop</em> model assumes that a process doesn’t deviate from its algorithm but doesn’t come back online if it crashes. Although this seems unrealistic for software crashes, it models unrecoverable hardware faults and generally makes the algorithms simpler.</li>
</ul>
<p>The arbitrary-fault model is typically used to model safety-critical systems like airplane engines, nuclear power plants, and systems where a single entity doesn’t fully control all the processes (e.g., digital cryptocurrencies such as Bitcoin). These use cases are outside the book’s scope, and the algorithms presented here will generally assume a crash-recovery model.</p>
<p>Finally, we can also model timing assumptions:</p>
<ul>
<li>The <em>synchronous</em> model assumes that sending a message or executing an operation never takes more than a certain amount of time. This is not very realistic for the type of systems we care about, where we know that sending messages over the network can potentially take a very long time, and processes can be slowed down by, e.g., garbage collection cycles or page faults.</li>
<li>The <em>asynchronous</em> model assumes that sending a message or executing an operation on a process can take an unbounded amount of time. Unfortunately, many problems can’t be solved under this assumption; if sending messages can take an infinite amount of time, algorithms can get stuck and not make any progress at all. Nevertheless, this model is useful because it’s simpler than models that make timing assumptions, and therefore algorithms based on it are also easier to implement<a href="#fn2" class="footnote-ref" id="fnref2" epub:type="noteref">2</a>.</li>
<li>The <em>partially synchronous</em> model assumes that the system behaves synchronously most of the time. This model is typically representative enough of real-world systems.</li>
</ul>
<p>In the rest of the book, we will generally assume a system model with fair-loss links, crash-recovery processes, and partial synchrony. If you are curious and want to learn more about other system models, “Introduction to Reliable and Secure Distributed Programming”<a href="#fn3" class="footnote-ref" id="fnref3" epub:type="noteref">3</a> is an excellent theoretical book that explores distributed algorithms for a variety of models not considered in this text.</p>
<p>But remember, models are just an abstraction of reality<a href="#fn4" class="footnote-ref" id="fnref4" epub:type="noteref">4</a> since they don’t represent the real world with all its nuances. So, as you read along, question the models’ assumptions and try to imagine how algorithms that rely on them could break in practice.</p>
</section>
<section class="footnotes" epub:type="footnotes">
<hr />
<ol>
<li id="fn1" epub:type="footnote"><p>“The Byzantine Generals Problem,” <a href="https://lamport.azurewebsites.net/pubs/byz.pdf" class="uri">https://lamport.azurewebsites.net/pubs/byz.pdf</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" epub:type="footnote"><p>“Unreliable Failure Detectors for Reliable Distributed Systems,” <a href="https://www.cs.utexas.edu/~lorenzo/corsi/cs380d/papers/p225-chandra.pdf" class="uri">https://www.cs.utexas.edu/~lorenzo/corsi/cs380d/papers/p225-chandra.pdf</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" epub:type="footnote"><p>“Introduction to Reliable and Secure Distributed Programming,” <a href="https://www.distributedprogramming.net/" class="uri">https://www.distributedprogramming.net/</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" epub:type="footnote"><p>“All models are wrong,” <a href="https://en.wikipedia.org/wiki/All_models_are_wrong" class="uri">https://en.wikipedia.org/wiki/All_models_are_wrong</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
