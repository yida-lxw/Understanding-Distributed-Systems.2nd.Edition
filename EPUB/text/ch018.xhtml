<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch018.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="time" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> Time</h1>
<p>Time is an essential concept in any software application; even more so in distributed ones. We have seen it play a crucial role in the network stack (e.g., DNS record TTL) and failure detection (timeouts). Another important use of it is for ordering events.</p>
<p>The flow of execution of a single-threaded application is simple to understand because every operation executes sequentially in time, one after the other. But in a distributed system, there is no shared global clock that all processes agree on that can be used to order operations. And, to make matters worse, processes can run concurrently.</p>
<p>It’s challenging to build distributed applications that work as intended without knowing whether one operation happened before another. In this chapter, we will learn about a family of clocks that can be used to work out the order of operations across processes in a distributed system.</p>
<section id="physical-clocks" class="level2" data-number="8.1">
<h2 data-number="8.1"><span class="header-section-number">8.1</span> Physical clocks</h2>
<p>A process has access to a physical wall-time clock. The most common type is based on a vibrating quartz crystal, which is cheap but not very accurate. Depending on manufacturing differences and external temperature, one quartz clock can run slightly faster or slower than others. The rate at which a clock runs faster or slower is also called <em>clock drift</em>. In contrast, the difference between two clocks at a specific point in time is referred to as <em>clock skew</em>.</p>
<p>Because quartz clocks drift, they need to be synced periodically with machines that have access to higher-accuracy clocks, like atomic ones. Atomic clocks<a href="#fn1" class="footnote-ref" id="fnref1" epub:type="noteref">1</a> measure time based on quantum-mechanical properties of atoms. They are significantly more expensive than quartz clocks and accurate to 1 second in 3 million years.</p>
<p>The synchronization between clocks can be implemented with a protocol, and the challenge is to do so despite the unpredictable latencies introduced by the network. The most commonly used protocol is the <em>Network Time Protocol</em> (NTP<a href="#fn2" class="footnote-ref" id="fnref2" epub:type="noteref">2</a>). In NTP, a client estimates the clock skew by receiving a timestamp from a NTP server and correcting it with the estimated network latency. With an estimate of the clock skew, the client can adjust its clock. However, this causes the clock to jump forward or backward in time, which creates a problem when comparing timestamps. For example, an operation that runs after another could have an earlier timestamp because the clock jumped back in time between the two operations.</p>
<p>Luckily, most operating systems offer a different type of clock that is not affected by time jumps: a monotonic clock. A <em>monotonic clock</em> measures the number of seconds elapsed since an arbitrary point in time (e.g., boot time) and can only move forward. A monotonic clock is useful for measuring how much time has elapsed between two timestamps on the same node. However, monotonic clocks are of no use for comparing timestamps of different nodes.</p>
<p>Since we don’t have a way to synchronize wall-time clocks across processes perfectly, we can’t depend on them for ordering operations across nodes. To solve this problem, we need to look at it from another angle. We know that two operations can’t run concurrently in a single-threaded process as one must happen before the other. This <em>happened-before</em> relationship creates a <em>causal</em> bond between the two operations, since the one that happens first can have side-effects that affect the operation that comes after it. We can use this intuition to build a different type of clock that isn’t tied to the physical concept of time but rather captures the causal relationship between operations: a logical clock.</p>
</section>
<section id="logical-clocks" class="level2" data-number="8.2">
<h2 data-number="8.2"><span class="header-section-number">8.2</span> Logical clocks</h2>
<p>A <em>logical clock</em> measures the passing of time in terms of logical operations, not wall-clock time. The simplest possible logical clock is a counter, incremented before an operation is executed. Doing so ensures that each operation has a distinct <em>logical timestamp</em>. If two operations execute on the same process, then necessarily one must come before the other, and their logical timestamps will reflect that. But what about operations executed on different processes?</p>
<p>Imagine sending an email to a friend. Any actions you did before sending that email, like drinking coffee, must have happened before the actions your friend took after receiving the email. Similarly, when one process sends a message to another, a so-called <em>synchronization point</em> is created. The operations executed by the sender before the message was sent <em>must</em> have happened before the operations that the receiver executed after receiving it.</p>
<p>A <em>Lamport clock</em><a href="#fn3" class="footnote-ref" id="fnref3" epub:type="noteref">3</a> is a logical clock based on this idea. To implement it, each process in the system needs to have a local counter that follows specific rules:</p>
<ul>
<li>The counter is initialized with 0.</li>
<li>The process increments its counter by 1 before executing an operation.</li>
<li>When the process sends a message, it increments its counter by 1 and sends a copy of it in the message.</li>
<li>When the process receives a message, it merges the counter it received with its local counter by taking the maximum of the two. Finally, it increments the counter by 1.</li>
</ul>
<div class="figure" style="text-align: center">
<img alt="Three processes using Lamport clocks. For example, because D happened before F, D&#39;s logical timestamp is less than F&#39;s." width="100%" src="../media/file11.png" />
<p class="caption">
Figure 8.1: Three processes using Lamport clocks. For example, because D happened before F, D’s logical timestamp is less than F’s.
</p>
</div>
<p>Although the Lamport clock assumes a crash-stop model, a crash-recovery one can be supported by e.g., persisting the clock’s state on disk.</p>
<p>The rules guarantee that if operation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mn>1</mn></msub><annotation encoding="application/x-tex">O_1</annotation></semantics></math> happened-before operation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mn>2</mn></msub><annotation encoding="application/x-tex">O_2</annotation></semantics></math>, the logical timestamp of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mn>1</mn></msub><annotation encoding="application/x-tex">O_1</annotation></semantics></math> is less than the one of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mn>2</mn></msub><annotation encoding="application/x-tex">O_2</annotation></semantics></math>. In the example shown in Figure <a href="#fig:lamport">8.1</a>, operation D happened-before F, and their logical timestamps, 4 and 5, reflect that.</p>
<p>However, two unrelated operations can have the same logical timestamp. For example, the logical timestamps of operations A and E are equal to 1. To create a strict total order, we can arbitrarily order the processes to break ties. For example, if we used the process IDs in Figure <a href="#fig:lamport">8.1</a> to break ties (1, 2, and 3), E’s timestamp would be greater than A’s.</p>
<p>Regardless of whether ties are broken, the order of logical timestamps doesn’t imply a causal relationship. For example, in Figure <a href="#fig:lamport">8.1</a>, operation E didn’t happen-before C, even if their timestamps appear to imply it. To guarantee this relationship, we have to use a different type of logical clock: a <em>vector clock</em>.</p>
</section>
<section id="vector-clocks" class="level2" data-number="8.3">
<h2 data-number="8.3"><span class="header-section-number">8.3</span> Vector clocks</h2>
<p>A <em>vector clock</em><a href="#fn4" class="footnote-ref" id="fnref4" epub:type="noteref">4</a> is a logical clock that guarantees that if a logical timestamp is less than another, then the former must have happened-before the latter. A vector clock is implemented with an array of counters, one for each process in the system. And, as with Lamport clocks, each process has its local copy.</p>
<p>For example, suppose the system is composed of three processes, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">P1</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">P2</annotation></semantics></math>, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">P3</annotation></semantics></math>. In this case, each process has a local vector clock implemented with an array<a href="#fn5" class="footnote-ref" id="fnref5" epub:type="noteref">5</a> of three counters <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>C</mi><mrow><mi>P</mi><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>C</mi><mrow><mi>P</mi><mn>2</mn></mrow></msub><mo>,</mo><msub><mi>C</mi><mrow><mi>P</mi><mn>3</mn></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[C_{P1}, C_{P2}, C_{P3}]</annotation></semantics></math>. The first counter in the array is associated with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">P1</annotation></semantics></math>, the second with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">P2</annotation></semantics></math>, and the third with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">P3</annotation></semantics></math>.</p>
<p>A process updates its local vector clock based on the following rules:</p>
<ul>
<li>Initially, the counters in the array are set to 0.</li>
<li>When an operation occurs, the process increments its counter in the array by 1.</li>
<li>When the process sends a message, it increments its counter in the array by 1 and sends a copy of the array with the message.</li>
<li>When the process receives a message, it merges the array it received with the local one by taking the maximum of the two arrays element-wise. Finally, it increments its counter in the array by 1.</li>
</ul>
<div class="figure" style="text-align: center">
<img alt="Each process has a vector clock represented by an array of three counters." width="100%" src="../media/file12.png" />
<p class="caption">
Figure 8.2: Each process has a vector clock represented by an array of three counters.
</p>
</div>
<p>The beauty of vector clock timestamps is that they can be partially ordered<a href="#fn6" class="footnote-ref" id="fnref6" epub:type="noteref">6</a>; given two operations <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mn>1</mn></msub><annotation encoding="application/x-tex">O_1</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mn>2</mn></msub><annotation encoding="application/x-tex">O_2</annotation></semantics></math> with timestamps <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>1</mn></msub><annotation encoding="application/x-tex">T_1</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>2</mn></msub><annotation encoding="application/x-tex">T_2</annotation></semantics></math>, if:</p>
<ul>
<li>every counter in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>1</mn></msub><annotation encoding="application/x-tex">T_1</annotation></semantics></math> is less than or equal to the corresponding counter in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>2</mn></msub><annotation encoding="application/x-tex">T_2</annotation></semantics></math>,</li>
<li>and there is at least one counter in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>1</mn></msub><annotation encoding="application/x-tex">T_1</annotation></semantics></math> that is strictly less than the corresponding counter in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>2</mn></msub><annotation encoding="application/x-tex">T_2</annotation></semantics></math>,</li>
</ul>
<p>then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mn>1</mn></msub><annotation encoding="application/x-tex">O_1</annotation></semantics></math> happened-before <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mn>2</mn></msub><annotation encoding="application/x-tex">O_2</annotation></semantics></math>. For example, in Figure <a href="#fig:vector">8.2</a>, B happened-before C.</p>
<p>If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mn>1</mn></msub><annotation encoding="application/x-tex">O_1</annotation></semantics></math> didn’t happen-before <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mn>2</mn></msub><annotation encoding="application/x-tex">O_2</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mn>2</mn></msub><annotation encoding="application/x-tex">O_2</annotation></semantics></math> didn’t happen-before <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mn>1</mn></msub><annotation encoding="application/x-tex">O_1</annotation></semantics></math>, then the timestamps can’t be ordered, and the operations are considered to be concurrent. So, for example, operations E and C in Figure <a href="#fig:vector">8.2</a> can’t be ordered, and therefore are concurrent.</p>
<p>One problem with vector clocks is that the storage requirement on each process grows linearly with the number of processes, which becomes a problem for applications with many clients. However, there are other types of logical clocks that solve this issue, like dotted version vectors<a href="#fn7" class="footnote-ref" id="fnref7" epub:type="noteref">7</a>.</p>
<p>This discussion about logical clocks might feel a bit abstract at this point but bear with me. Later in the book, we will encounter some practical applications of logical clocks. What’s important to internalize at this point is that, in general, we can’t use physical clocks to accurately derive the order of events that happened on different processes. That being said, sometimes physical clocks are good enough. For example, using physical clocks to timestamp logs may be fine if they are only used for debugging purposes.</p>
</section>
</section>
<section class="footnotes" epub:type="footnotes">
<hr />
<ol>
<li id="fn1" epub:type="footnote"><p>“Atomic clock,” <a href="https://en.wikipedia.org/wiki/Atomic_clock" class="uri">https://en.wikipedia.org/wiki/Atomic_clock</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" epub:type="footnote"><p>“RFC 5905: Network Time Protocol Version 4: Protocol and Algorithms Specification,” <a href="https://datatracker.ietf.org/doc/html/rfc5905" class="uri">https://datatracker.ietf.org/doc/html/rfc5905</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" epub:type="footnote"><p>“Time, Clocks, and the Ordering of Events in a Distributed System,” <a href="http://lamport.azurewebsites.net/pubs/time-clocks.pdf" class="uri">http://lamport.azurewebsites.net/pubs/time-clocks.pdf</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" epub:type="footnote"><p>“Timestamps in Message-Passing Systems That Preserve the Partial Ordering,” <a href="https://fileadmin.cs.lth.se/cs/Personal/Amr_Ergawy/dist-algos-papers/4.pdf" class="uri">https://fileadmin.cs.lth.se/cs/Personal/Amr_Ergawy/dist-algos-papers/4.pdf</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" epub:type="footnote"><p>In actual implementations, a dictionary is used rather than an array.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" epub:type="footnote"><p>In a total order, every pair of elements is comparable. Instead, in partial order, some pairs are not comparable<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" epub:type="footnote"><p>“Why Logical Clocks are Easy,” <a href="https://queue.acm.org/detail.cfm?id=2917756" class="uri">https://queue.acm.org/detail.cfm?id=2917756</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
