<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch047.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="operations-intro" class="level1 unnumbered unlisted">
<h1 class="unnumbered unlisted">Introduction</h1>
<blockquote>
<p><em>“Everyone knows that debugging is twice as hard as writing a program in the first place. So if you’re as clever as you can be when you write it, how will you ever debug it?”</em></p>
<p>– Brian Kernighan</p>
</blockquote>
<p>It’s a well-known fact that the majority of the cost of software is spent after its initial development in maintenance activities, such as fixing bugs, adding new features, and operating it. Thus, we should aspire to make our systems easy to modify, extend and operate so that they are easy to maintain.</p>
<p>Good testing — in the form of unit, integration, and end-to-end tests — is a minimum requirement to be able to modify or extend a system without worrying it will break. And once a change has been merged into the codebase, it needs to be released to production safely without affecting the application’s availability. Also, the operators need to be able to monitor the system’s health, investigate degradations and restore the service when it gets into a bad state. This requires altering the system’s behavior without code changes, e.g., toggling a feature flag or scaling out a service with a configuration change.</p>
<p>Historically, developers, testers, and operators were part of different teams. First, the developers handed over their software to a team of QA engineers responsible for testing it. Then, when the software passed that stage, it moved to an operations team responsible for deploying it to production, monitoring it, and responding to alerts. However, this model is being phased out in the industry. Nowadays, it’s common for developers to be responsible for testing and operating the software they write, which requires embracing an end-to-end view of the software’s lifecycle.</p>
<p>In this part, we will explore some of the best practices for testing and operating large distributed applications.</p>
<p>Chapter <a href="#testing">29</a> describes the different types of tests — unit, integration, and end-to-end tests — that we can leverage to increase the confidence that a distributed application works as expected. This chapter also explores the use of formal verification methods to verify the correctness of an application before writing a single line of code.</p>
<p>Chapter <a href="#cd">30</a> dives into continuous delivery and deployment pipelines to release changes safely and efficiently to production.</p>
<p>Chapter <a href="#monitoring">31</a> discusses how to use metrics, service-level indicators, and dashboards to monitor the health of distributed applications. It then talks about how to define and enforce service-level objectives that describe how the service should behave when it’s functioning correctly.</p>
<p>Chapter <a href="#observability">32</a> introduces the concept of observability and its relation to monitoring. Later, it describes how to debug production issues using logs and traces.</p>
<p>Chapter <a href="#manageability">33</a> describes how to modify a system’s behavior without changing its code, which is a must-have to enable operators to quickly mitigate failures in production when everything else fails.</p>
</section>
</body>
</html>
