<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch011.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="dns" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Discovery</h1>
<p>So far, we have explored how to create a reliable and secure channel between two processes running on different machines. However, to create a new connection with a remote process, we must first discover its IP address somehow. The most common way of doing that is via the phone book of the internet: the <em>Domain Name System</em><a href="#fn1" class="footnote-ref" id="fnref1" epub:type="noteref">1</a> (DNS) — a distributed, hierarchical, and eventually consistent key-value store.</p>
<p>In this chapter, we will look at how DNS resolution<a href="#fn2" class="footnote-ref" id="fnref2" epub:type="noteref">2</a> works in a browser, but the process is similar for other types of clients. When you enter a URL in your browser, the first step is to resolve the hostname’s IP address, which is then used to open a new TLS connection. For example, let’s take a look at how the DNS resolution works when you type <em>www.example.com</em> into your browser (see Figure <a href="#fig:DNS">4.1</a>).</p>
<ol type="1">
<li><p>The browser checks its local cache to see whether it has resolved the hostname before. If so, it returns the cached IP address; otherwise, it routes the request to a DNS resolver, a server typically hosted by your Internet Service Provider (ISP).</p></li>
<li><p>The resolver is responsible for iteratively resolving the hostname for its clients. The reason why it’s iterative will become obvious in a moment. The resolver first checks its local cache for a cached entry, and if one is found, it’s returned to the client. If not, the query is sent to a root name server (root NS).</p></li>
<li><p>The root name server maps the <em>top-level domain</em> (TLD) of the request, i.e., <em>.com</em>, to the address of the name server responsible for it.</p></li>
<li><p>The resolver sends a resolution request for <em>example.com</em> to the TLD name server.</p></li>
<li><p>The TLD name server maps the <em>example.com</em> domain name to the address of the <em>authoritative name server</em> responsible for the domain.</p></li>
<li><p>Finally, the resolver queries the authoritative name server for <em>www.example.com</em>, which returns the IP address of the <em>www</em> hostname.</p></li>
</ol>
<p>If the query included a subdomain of <em>example.com</em>, like <em>news.example.com</em>, the authoritative name server would have returned the address of the name server responsible for the subdomain, and an additional request would be required.</p>
<div class="figure" style="text-align: center">
<img alt="DNS resolution process" width="100%" src="../media/file8.png" />
<p class="caption">
Figure 4.1: DNS resolution process
</p>
</div>
<p>The original DNS protocol sent plain-text messages primarily over UDP for efficiency reasons. However, because this allows anyone monitoring the transmission to snoop, the industry has mostly moved to secure alternatives, such as DNS on top of TLS<a href="#fn3" class="footnote-ref" id="fnref3" epub:type="noteref">3</a>.</p>
<p>The resolution process involves several round trips in the worst case, but its beauty is that the address of a root name server is all that’s needed to resolve a hostname. That said, the resolution would be slow if every request had to go through several name server lookups. Not only that, but think of the scale required for the name servers to handle the global resolution load. So caching is used to speed up the resolution process since the mapping of domain names to IP addresses doesn’t change often — the browser, operating system, and DNS resolver all use caches internally.</p>
<p>How do these caches know when to expire a record? Every DNS record has a <em>time to live</em> (TTL) that informs the cache how long the entry is valid for. But there is no guarantee that clients play nicely and enforce the TTL. So don’t be surprised when you change a DNS entry and find out that a small number of clients are still trying to connect to the old address long after the TTL has expired.</p>
<p>Setting a TTL requires making a tradeoff. If you use a long TTL, many clients won’t see a change for a long time. But if you set it too short, you increase the load on the name servers and the average response time of requests because clients will have to resolve the hostname more often.</p>
<p>If your name server becomes unavailable for any reason, then the smaller the record’s TTL is, the higher the number of clients impacted will be. DNS can easily become a single point of failure — if your DNS name server is down and clients can’t find the IP address of your application, they won’t be able to connect it. This can lead to massive outages<a href="#fn4" class="footnote-ref" id="fnref4" epub:type="noteref">4</a>.</p>
<p>This brings us to an interesting observation. DNS could be a lot more robust to failures if DNS caches would serve stale entries when they can’t reach a name server, rather than treating TTLs as time bombs. Since entries rarely change, serving a stale entry is arguably a lot more robust than not serving any entry at all. The principle that a system should continue to function even when a dependency is impaired is also referred to as “static stability”; we will talk more about it in the resiliency part of the book.</p>
</section>
<section class="footnotes" epub:type="footnotes">
<hr />
<ol>
<li id="fn1" epub:type="footnote"><p>“RFC 1035: Domain Names - Implementation and Specification,” <a href="https://datatracker.ietf.org/doc/html/rfc1035" class="uri">https://datatracker.ietf.org/doc/html/rfc1035</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" epub:type="footnote"><p>“A deep dive into DNS,” <a href="https://www.youtube.com/watch?v=drWd9HIhJdU" class="uri">https://www.youtube.com/watch?v=drWd9HIhJdU</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" epub:type="footnote"><p>“RFC 7858: Specification for DNS over Transport Layer Security (TLS),” <a href="https://en.wikipedia.org/wiki/DNS_over_TLS" class="uri">https://en.wikipedia.org/wiki/DNS_over_TLS</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" epub:type="footnote"><p>“DDoS attack on Dyn,” <a href="https://en.wikipedia.org/wiki/2016_Dyn_cyberattack" class="uri">https://en.wikipedia.org/wiki/2016_Dyn_cyberattack</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
