<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch006.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 分布式系统介绍</h1>
<blockquote>
<p><em>“分布式系统指的是这样一个系统:在该系统中, 一台您甚至不知道它存在的计算机发生故障,可能会因此导致您自己的计算机无法使用。”</em></p>
<p>– Leslie Lamport(莱斯利·兰伯特)</p>
</blockquote>
<p>广义上来说，分布式系统是一组节点通过通信链路交换消息以完成某些任务的集合。节点可以泛指物理机器，比如手机，或软件进程，比如浏览器。</p>
<p>为什么我们一开始要费心构建分布式系统?</p>
<p>有些应用程序天生就是分布式的。比如，互联网是一个您非常熟悉的分布式系统。您通过浏览器访问它，而该浏览器运行在您的手机、平板电脑、台式机或Xbox上，与全球数十亿其他设备一起，它构成了一个分布式系统。</p>
<p>构建分布式系统的另一个原因就是，某些应用程序需要具有高可用性，而且需要能够抵御单节点故障。例如，Dropbox会将您的数据复制到多个节点上，这样即使单个节点丢失，也不会导致您的数据丢失。</p>
<p>某些应用程序需要处理巨大工作负载，即无论单个节点机器性能多么强劲都无法容纳的工作负载。例如，谷歌每秒从全球各地接收数以万计的搜索请求。单个节点根本无法处理这些请求。</p>
<p>最后，某些应用程序的性能要求在物理上是不可能通过单个节点实现的。Netflix可以以高分辨率无缝地将电影流式的传输到您的电视上，是因为它有一个靠近您的数据中心。</p>
<p>这本书探讨了设计、构建和运维分布式系统所需解决的根本挑战。</p>
<section id="communication" class="level2" data-number="1.1">
<h2 data-number="1.1"><span class="header-section-number">1.1</span> 通信</h2>
<p>第一个挑战来自于节点需要通过网络互相通信。例如，当您的浏览器想要加载一个网站时，它会从URL解析服务器的IP地址，并向它发送一个HTTP请求。反过来，服务器会响应页面的内容。</p>
<p>请求和响应消息在网络传输中是如何表示的？当出现临时网络中断，或某个发生故障的网络交换机翻转了消息中的几个比特位时，会发生什么？服务器如何确保没有中间人能窃听通信？</p>
<p>就算假定某些网络库抽象了所有通信相关问题能够带来便利，但是实际上，由于抽象泄露<a href="#fn1" class="footnote-ref" id="fnref1" epub:type="noteref">1</a>问题的存在，事情往往并没有那么简单。当这种情况发生时，你需要理解网络协议栈的工作原理。</p>
</section>
<section id="coordination" class="level2" data-number="1.2">
<h2 data-number="1.2"><span class="header-section-number">1.2</span> 协调</h2>
<p>构建分布式系统的另一个艰巨挑战是，需要某种形式的协调才能使各个节点协同工作以实现共同目标。在存在失败的情况下，这一点尤其具有挑战性。“两将军”问题是一个著名的思想实验，它就证明了这一点。</p>

<p>假设有两个将军(节点)，各自指挥自己的军队，需要商定一个时间共同攻打一座城市。两个军队之间有一定的距离(网络)，唯一的通讯方式是通过信使，而信使可能会被敌人俘获(网络故障)。在这些假设下，将军们有办法商定一个时间吗？</p>
<p>嗯，将军1可以向将军2发送一条包含提议时间的消息。但是，由于信使可能被俘获，将军1无法确认消息是否实际送达。你可以争辩说：将军2可以派一个信使捎带回信来确认他已收到原始消息。然而，就像之前一样，将军2也无法确认回信是否实际送达，此时又需要另一次确认。结果证明，无论进行多少轮确认，两位将军都无法确认另一支军队是否会同时攻打城市。正如你所见，解决这个问题比最初看起来要难得多。</p>
<p>由于协调是一个如此关键的主题, 因此本书的第二部分将致力于深入理解用于实现分布式协调的基础分布式算法。</p>
</section>
<section id="scalability" class="level2" data-number="1.3">
<h2 data-number="1.3"><span class="header-section-number">1.3</span> 可扩展性</h2>
<p>应用程序的性能代表了它处理<em>负载</em>的效率。直观来说，负载是指消耗系统资源(如CPU、内存和网络带宽)的任何事物。由于负载的性质取决于应用程序的使用场景和架构，因此可以用不同方式来衡量它。例如，并发用户数量或读写比例都是负载的不同形式。</p>
<p>对于本书中讨论的应用程序类型，性能通常通过吞吐量和响应时间来衡量。<em>吞吐量</em>指的是应用程序每秒处理的请求数，而<em>响应时间</em>指的是向应用程序发送请求和接收响应之间经历的时间(单位:秒)。</p>
<p>随着负载增加，当资源耗尽时，应用程序最终会达到其<em>容量</em>，即它能承受的最大负载。此时性能要么达到平稳期，要么恶化, 正如图 <a href="#fig:capacity">1.1</a>所示. 若系统负载持续增长，最终将达到一个临界点，此时大部分操作要么失败，要么超时。</p>
<div class="figure" style="text-align: center">
<img alt="y轴上的系统吞吐量是可以在没有错误和低响应时间的情况下处理的客户端请求(x轴)的子集，也称为其有效吞吐量。" width="100%" src="../media/file0.png" />
<p class="caption">
图 1.1: y轴上的系统吞吐量是可以在没有错误和低响应时间的情况下处理的客户端请求(x轴)的子集，也称为其有效吞吐量。
</p>
</div>
<p>分布式系统的容量取决于其架构、实现以及复杂的物理限制网络，例如节点的内存大小和时钟周期以及网络链接的带宽和延迟。为了使应用程序具有可扩展性，负载增加不应降低应用程序的性能。它要求支持随意增加应用程序的容量。</p>
<p>一种快速简单的方法是购买性能更好的更昂贵的硬件，这也被称作<em>垂直扩展</em>。不幸的是，当这样的硬件不存在时，这种方法迟早会碰壁。替代方案是通过向系统中添加更多通用服务器并让它们协同工作来进行<em>水平扩展</em>。</p>
<p>尽管在几十年前随意增购服务器可能令人望而却步，但云服务商的兴起已使这一操作变得轻而易举。2006年亚马逊推出亚马逊网络服务(AWS)，其弹性云计算(EC2<a href="#fn2" class="footnote-ref" id="fnref2" epub:type="noteref">2</a>)服务提供了虚拟机租赁能力。自此以后，云服务商及其服务数量持续增长，大幅降低了构建可扩展应用的技术门槛。</p>


<p>在本书的第三部分，我们将探讨可扩展云原生应用的核心架构模式与基础组件。</p>
</section>
<section id="resiliency" class="level2" data-number="1.4">
<h2 data-number="1.4"><span class="header-section-number">1.4</span> 弹性</h2>
<p>当分布式系统即使发生故障也能继续完成工作时，我们就说它具有弹性。在规模扩大时，任何可能出错的事情将会出错。每个组件都有发生故障的概率 — 节点可能崩溃，网络链接可能被中断等等。无论这个概率有多小，只要组件越多，系统执行的操作越多，故障的数量就会越高。情况也会变得更糟，因为如果组件没有很好地隔离，一个组件的故障可能会增加另一个组件发生故障的概率。</p>
<p>未检查的故障可能会影响系统的<em>可用性</em><a href="#fn3" class="footnote-ref" id="fnref3" epub:type="noteref">3</a>，即系统可供使用的时间百分比。它的比率定义为应用程序可以服务请求的时间(<em>uptime</em>)除以测量的总时间(<em>uptime</em>加上<em>downtime</em>，<em>downtime</em>即应用程序无法服务请求的时间)。</p>
<p>可用性通常以"9"的数量级来描述，这是一种表示可用百分比的简写方式。三个9(99.9%)通常被认为是用户可接受的最低标准，而达到四个9(99.99%)及以上的系统则被视为高可用。</p>
<table>
<thead>
<tr class="header">
<th>可用性 %</th>
<th>每天服务不可用时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>90% (“1个9”)</td>
<td>2.40 小时</td>
</tr>
<tr class="even">
<td>99% (2个9”)</td>
<td>14.40 分钟</td>
</tr>
<tr class="odd">
<td>99.9% (“3个9”)</td>
<td>1.44 分钟</td>
</tr>
<tr class="even">
<td>99.99% (“4个9”)</td>
<td>8.64 秒</td>
</tr>
<tr class="odd">
<td>99.999% (“5个9”)</td>
<td>864 毫秒</td>
</tr>
</tbody>
</table>
<p>如果系统无法抵御故障，其可用性将不可避免地下降。因此，分布式系统需要接受故障，并准备好使用冗余、故障隔离和自愈机制等技术来抵御故障，我们将在本书第四部分<em>弹性</em> 中讨论这些技术。</p>
</section>
<section id="maintainability" class="level2" data-number="1.5">
<h2 data-number="1.5"><span class="header-section-number">1.5</span> 可维护性</h2>
<p>众所周知，软件的大部分成本都花在了初始开发之后的维护上，比如修复Bug、添加新功能和日常运维。因此，我们应该努力使我们的系统易于修改、扩展和运维，以便它们易于维护。</p>
<p>任何变更都可能引发潜在故障。良好的测试 — 以单元测试、集成测试和全链路测试的形式 — 是修改或扩展系统而不必担心系统会崩溃的最低要求。一旦更改被合并到代码库中，它需要安全地发布到生产环境中，而不会影响系统的可用性。</p>
<p>此外，运维人员需要监控系统的健康状况、调查降级情况并在无法自愈时恢复服务。这需要在不更改代码的情况下更改系统的行为，例如，切换功能标志位或通过更改配置来水平扩展服务。</p>
<p>一直以来，开发人员、测试人员和运维人员属于不同团队，但微服务和DevOps的兴起改变了这一切。如今，同一个团队内设计和实现系统的人员同时也负责测试和运维。这是一件好事，因为没有比随时待命更好的方法来发现系统的不足之处。本书第五部分将探索测试和运维分布式系统的最佳实践。</p>
</section>
<section id="anatomy-of-a-distributed-system" class="level2" data-number="1.6">
<h2 data-number="1.6"><span class="header-section-number">1.6</span> 分布式系统架构解析</h2>
<p>分布式系统形态和规模各异。在这本书中，我们主要关注运行在通用机器上并实现某种业务服务的后端应用程序。因此，可以说分布式系统是一组通过网络链路进行通信的机器。然而，从运行时角度来看，分布式系统是一组通过<em>进程间通信</em>(IPC)机制如HTTP进行通信的软件进程。从实现角度来看，分布式系统是一组通过API进行通信的松散耦合组件(服务)。所有这些都是有效的和有用的架构视角。在本书的其余部分，我们将根据具体议题灵活切换论述视角。</p>
<p>一个<em>服务</em>实现了整体系统功能的一个特定部分。服务的核心是业务逻辑，它暴露接口以与外界通信。一些接口定义了服务向其用户提供的一些操作。相比之下，其他接口定义了服务可以在其他服务上调用的操作，如数据存储、消息代理等。</p>
<p>由于进程无法直接调用彼此的接口，因此需要通过<em>适配器</em>将进程间通信(IPC)机制与服务接口连接。入站适配器是服务<em>应用程序编程接口</em>(API)的组成部分，它通过调用服务接口中定义的操作来处理从IPC机制(如HTTP)接收到的请求。相反，出站适配器允许业务逻辑访问外部服务，如数据存储。这种架构风格也被称为端口与适配器架构<a href="#fn4" class="footnote-ref" id="fnref4" epub:type="noteref">4</a>。其设计理念是业务逻辑不取决于技术细节;相反，技术细节取决于业务逻辑(依赖倒置原则<a href="#fn5" class="footnote-ref" id="fnref5" epub:type="noteref">5</a>)。图<a href="#fig:service">1.2</a>直观演示了这一设计理念。</p>
<div class="figure" style="text-align: center">
<img alt="In this example, the business logic uses the repository interface, implemented by the PostgreSQL adapter, to access the database. In contrast, the HTTP adapter handles incoming requests by calling operations defined in the service interface." width="100%" src="../media/file1.png" />
<p class="caption">
图 1.2: 在此示例中，业务逻辑使用由PostgreSQL适配器实现的存储接口来访问数据库。相比之下，HTTP适配器通过调用服务接口中定义的操作来处理输入的请求。
</p>
</div>
<p>继续，我们将将运行服务的进程称为<em>服务器</em>，并将向服务器发送请求的进程称为<em>客户端</em>。有时，一个进程既是客户端又是服务端。为了简单起见，我们假设服务的单个实例完全在单个服务器进程中运行。类似地，我们还假设一个进程只有一个线程。这些假设将使我们忽略一些实现细节，而这些实现细节只会使讨论复杂化，但并不会增加太多价值。</p>
<!--chapter:end:markdown/Introduction.Rmd-->
</section>
</section>
<section class="footnotes" epub:type="footnotes">
<hr />
<ol>
<li id="fn1" epub:type="footnote"><p>“抽象泄露定律,” <a href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/" class="uri">https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" epub:type="footnote"><p>亚马逊 EC2,” <a href="https://aws.amazon.com/ec2/" class="uri">https://aws.amazon.com/ec2/</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" epub:type="footnote"><p>“AWS架构良好的框架，可用性，” <a href="https://docs.aws.amazon.com/wellarchitected/latest/reliability-pillar/availability.html" class="uri">https://docs.aws.amazon.com/wellarchitected/latest/reliability-pillar/availability.html</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" epub:type="footnote"><p>“端口与适配器架构,” <a href="http://wiki.c2.com/?PortsAndAdaptersArchitecture" class="uri">http://wiki.c2.com/?PortsAndAdaptersArchitecture</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" epub:type="footnote"><p>“依赖倒置原则,” <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" class="uri">https://en.wikipedia.org/wiki/Dependency_inversion_principle</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
